<html lang="en">
<title>ABC259Ex translation</title>
<script src="https://cdn.jsdelivr.net/npm/texme@1.2.0"></script>
<textarea>
 
想到根号分治就会了。

对于出现次数少于 $n$ 次的颜色，直接两两枚举。

否则就直接在大矩阵上跑 DP。

复杂度为 $O(n^3)$，分析易证。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
int const N=405,MOD=998244353;
int n,ans,a[N][N],b[N][N],f[N][N];
vector<pair<int,int> >p[N*N];
namespace combinatorics{
	static int const N=2333;
	int fac[N],inv[N];
	int qpow(int x,int y){
		return y?qpow(x*x%MOD,y>>1)*(y&1?x:1)%MOD:1;
	}
	int C(int n,int m){
		return n<m||m<0?0:fac[n]*inv[m]%MOD*inv[n-m]%MOD;
	}
	void init(){
		fac[0]=fac[1]=inv[0]=inv[1]=1;
		for(int i=2;i<N;i++)
			fac[i]=fac[i-1]*i%MOD;
		inv[N-1]=qpow(fac[N-1],MOD-2);
		for(int i=N-1;i>1;i--)
			inv[i-1]=inv[i]*i%MOD;
	}
}
using namespace combinatorics;
signed main(){
	ios::sync_with_stdio(0);
	init();
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j],p[a[i][j]].push_back({i,j});
	for(int i=1;i<=n*n;i++)
		if(p[i].size()<n){
			int m=p[i].size();
			for(int x=0;x<m;x++)
				for(int y=x;y<m;y++){
					int di=p[i][x].first-p[i][y].first,
						dj=p[i][x].second-p[i][y].second;
					if(di*dj<0)continue;
					di=abs(di),dj=abs(dj),ans=(ans+C(di+dj,dj))%MOD;
				}
		}else{
			memset(b,0,sizeof b);
			memset(f,0,sizeof f);
			for(auto&j:p[i])
				b[j.first][j.second]++;
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					f[i][j]=(f[i-1][j]+f[i][j-1])%MOD,
					b[i][j]&&(ans=(ans+ ++f[i][j])%MOD);
		}
  cout<<ans<<"\n";
}
```

</textarea>
